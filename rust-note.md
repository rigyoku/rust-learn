# Rust Note

## 01 入门

### 1.1 安装
* 通过`rustup`安装

### 1.2 hello world
* rust文件命名规则
    * 以`.rs`结尾
    * 全小写, 使用下划线分隔单词
* 每行代码以分号`;`结尾
* `main`函数作为入口
    * `fn`作为定义函数的关键字
* `println!` 完成打印输出
    * `!` 标志着是调用一个`宏(macro)`, 
* rust使用4个空格控制缩进
* 通过`rustc <文件路径>`编译, 生成可执行文件
    * 运行时不需要rust环境

### 1.3 cargo
* `cargo`是rust的包管理工具和构建工具
    * 通过`rustup`安装时, 自动安装了`cargo`
* `cargo new <工程名>` 创建一个新的工程
    * 添加参数`--vcs none`可以屏蔽使用git做版本管理
* `Cargo.toml`为工程的配置文件
    * 声明了名字, 工程版本, rust版本和依赖
    * rust中, 代码包被称为`crates`
* `src`路径存放代码
* 可以通过`cargo init`来初始化`Cargo.toml`
* 通过`cargo run`直接运行
* 通过`cargo check`可以快速检查代码
* 通过`cargo build`打包生成可执行文件, 放在target/debug下
    * 通过添加`--release`参数, 可以打生产包

## 02 猜数字例子
* 通过`use`关键字引用库
    * `std`标准库
        * 默认已经引入了一些标准库的库
        * `io`库, 可以获取输入
            * 通过`io::stdin()`可以获取标准终端输入
            * `read_line`会把输入内容追加到参数字符串中
            * `expect`做异常提示, `Result`枚举类型的异常情况发生后, 参数会在异常时打印在开头
* 通过`let`声明变量
    * 通过`mut`标注为可变变量
* 通过`//`写行注释
* `String`为std提供的可变长字符串
* `::`关联函数是针对于类型的实现函数
    * 通过`::new()`调用new函数, 创建新的实例
* 通过`&`表示引用, 和java/js的引用型一样, 一次赋值会影响其他取值的地方
    * 默认也是不可变, 可以通过`&mut`标记为可变
* 通过`println`打印时, 使用类似python模板字符串语法
    * 使用大括号`{}`作为占位符
    * 如果占位符内部为空, 则按顺序使用后续参数列表来填充
    * 占位符内可以直接写变量名, 就不必写到参数列表中了
    * 参数列表数量 = 空占位符数量
* 引入`rand`这个`crate`来使用随机数功能
    * `crate`是一组rust源代码文件, 无法单独执行
    * `Cargo.toml`直接写版本号相当于前面添加了`^`, 小版本变, 中版本不可变
* `Cargo.lock`和js的`package-lock.json`一样, 用于锁版本, 自动生成, 避免自动拉取新版依赖
    * 通过`cargo update`命令获取最新依赖, 并更新`Cargo.lock`文件
* `cargo doc --open`查看文档, 左侧可以查看依赖的包的文档
* 使用2个点表示范围表达式, 例如`0..2`, 表示0<=x<2
    * 可以添加等号, 表示包含结尾, 例如`0..=2`, 表示0<=x<=2
    * 可以省略右侧变为无限长度, 循环时不能省略左侧, 切片可以
    * 范围表达式可以作为for循环的范围
* 通过`cmp`包进行比较, 并处理返回的枚举
* `match`相当于其他语言`switch`, 格式为 match xx {}
    * 通过箭头来指向处理逻辑, 例如: `Ordering::Less => println!("猜小了"),`
    * 相当于自动break了
    * 注意分支间是逗号, 而不是分号了
* 相同的类型才能进行比较
* rust支持做同名的不同类型来进行覆盖
* `loop`关键字的代码块做死循环, 配合`break`跳出
* 除了用`expect`提示之外, 还能通过`match`做异常处理, 分别处理`Ok`和`Err`

## 03 编程概念

### 变量和常量
* 通过`let`声明变量, 变量默认是不可变的, 类似于final这种, 赋值一次之后没法改了 (果然大家还是更喜欢不可变性)
    * 声明时添加`mut`关键字, 标记为可变变量, 例如 `let mut a = 1;`
    * 通过`let`再次声明可以在作用域内覆盖(或者说是隐藏)前面的同名变量
    * `mut`无法改变类型, 而覆盖可以改变类型
* 通过`const`声明常量, 声明时必须初始化, 必须指定类型, 无法额外添加`mut`关键字 (规则也是全大写, 下划线分隔)

### 数据类型
* rust是静态类型语言, 编译时候就必须知道类型

#### 标量
* 整型没有小数点
    * 使用`u`或`i`开头. `u`是无符号, 只能是正数. `i`是有符号, 可以是负数.
    * 可以使用`u8`,`u16`,`u32`,`u64`,`u128`, 数字代表二进制位数, `u8`代表0~255, `i8`代表-127~128
    * 特殊的长度`isize`和`usize`, 依赖于cpu架构, 64位就是64, 32位就是32.
    * 可以在整数中用`_`分隔, 提高可读性.
    * debug模式溢出会报错, release会变为最小值
    * 除法会舍去小数位
    * 取余数也是用`%`
    * 不支持`++`, 可以做`+=`
* 浮点数有小数点, 有`f32`和`f64`2种, 默认`f64`
* 布尔型使用`bool`表示, 可以为`true`或`false`
* 字符类型使用`char`表示, 可以存储4个字节, 中文, 日文, 带音标的都可以存储, 使用`''`单引号包裹

#### 复合类型
* 元组(tuple)
    * 可以存储不同的类型
    * 声明后长度不可变
    * 使用小括号声明`()`, 逗号分隔项目
    * 索引从0开始, 可以通过`.索引号`来访问
    * 也可以使用小括号`()`来解构取值
        * 可以用`..`占位, 来取剩余项目
        * 元组不支持`@ ..`获取剩余项目, 因为元组可以是不同类型
    * 空的括号`()`表示单元元组(`unit`), 表示空值或空返回值类型, 是表达式的默认返回值
* 数组
    * 所有项目的类型相同
    * 声明后长度不可变. (标准库提供vector类型, 类似数组但是可变长)
    * 使用中括号声明`[]`, 逗号分隔项目
    * 声明类型时, 指定类型和长度, 分号分隔, 例如`[i32;5]`
    * 初始化时, 也可以用分号模式填充, 代表使用重复元素来填充
    * 索引从0开始, 可以通过`[索引号]`来访问
    * 也可以使用`[]`来解构取值
        * 可以用`..`占位, 来取剩余项目
        * 可以通过`@ ..`获取剩余项目, 例如`let a = [19,2,4,5];let [c, d, other @ ..] = a;`
    * 越界也会报错

### 函数
* 函数名全小写, 下划线分隔 (变量也是一样)
* `main`函数作为入口, `fn`定义函数, 小括号放参数列表, 大括号是函数内容
* rust也会做声明提前, 只要作用域内对方法可见, 就能调用, 可以先写调用后写声明
* 参数列表必须声明类型, 使用逗号分隔
* rust是基于`表达式`的语言
    * `语句`是执行操作, 没有返回值. 比如不能写`let a = (let b = 8)`, 因为`let`定义没有返回值
    * `表达式`是计算并产生一个新的值
        * 大括号产生的作用域块就是一个表达式
        * 表达式的结尾没有分号, 加了分号就变成语句了
* 返回值类型放在箭头之后`->`, 必须声明, 函数最后一行写表达式作为返回值

### 注释
* 使用`//`写单行注释
* 后续还会学到文档注释

### 流程控制
* 条件语句
    * if后直接跟布尔值, (不要求小括号, 写了也可以,) 后面用大括号放分歧的逻辑
    * 必须是布尔值, 不会自动转型, (比如js那种0转false)
    * 多分歧可以加`else`和`else if`
    * let声明时, 可以用if, (实现类似于三元表达式)
        * 多个分歧返回类型必须相同
    * == 判断相等, != 判断不相等
* 循环语句
    * loop死循环, 后面用大括号写逻辑
        * break跳出
        * continue跳过本次循环
        * 用的大括号所以能有返回值, break后面返回值, (写不写逗号都能执行)
        * 每次break/continue都只对最近一层生效
            * 可以为loop命名, 单引号开头, 然后break指定loop, 例如`'name:loop{}`
            * 返回时先写loop名, 再写返回值, 例如`break 'name 1;`
    * while计算循环, 先写布尔值, 然后是大括号写逻辑
        * 布尔为true时执行循环
    * for遍历循环
        * `for el in arr` 来获取每个元素
        * 也可以配合range来做固定次数的循环, 例如`for num in (1..4)`
            * range的rev方法用来翻转

## 04 所有权

### 概念
* 所有权是rust管理内存的规则
    * 不同于java的垃圾回收和c的手动分配, rust采用所有权规则来在编译期间进行检查, (不会影响运行速率)
    * 所有权规则
        * 每个值都有一个所有者
        * 任意时刻有且只有一个所有者
        * 当所有者离开作用域, 值被丢弃 (通过Drop方法释放)
* 栈
    * 后进先出
    * 栈内数据必须是已知的固定大小
* 堆
    * 缺乏组织
    * 分配内存方式: 
        * 先声明要请求的内存大小
        * 内存分配器在堆上找到合适的位置(地址)
        * 标记地址为已使用, 返回该地址的指针
* 字符串类型String
    * 硬编码的字符串是不可变的, (比如没有push_str方法来拼接)
    * 通过String::from可以从字面量获取可变字符串
    * 硬编码可以在编译时知道内容, 可放入栈. 而动态字符串只能放入堆.
* 将变量赋值给变量
    * 对于栈中的数据, 会复制一个实例放入栈里
    * 对于堆中的数据, 以字符串为例子
        * java复制的是指针. 2个指针共同指向同一块堆中的内容.
        * rust会把目标变量指向堆, 同时使原变量无效化. (属于移动, 而非浅拷贝)
            * 后续会学到通过实现Copy来保证原变量可用, 比如整形, 布尔等都实现了该方法所以可以赋值后再使用.
            * 元组的项目都是实现了Copy的类型时, 也是可以赋值后再使用的
    * 如果需要复制一份堆中的数据, 可以使用clone方法. (堆里存放2份数据, 耗费资源)
* 在表达式中使用变量就会发生所有权的转移
* 变量和方法
    * 作为参数的变量, 和赋值给其他变量一样, 堆中数据默认会采用移动的方式, 方法结束后Drop. (方法的下一行无法再使用变量.)
    * 方法的返回值, 会把所有权交给接收的变量

### 引用(借用)
* 变量作为方法参数就会失效会比较麻烦, 后续需要使用时, 每次都要返回原变量, 可以通过引用解决
* 引用的关键字为`&`, 类型声明为`&类型`, 使用时也用`&变量`来获取引用
    * 像是指针, 可以访问数据, 而不移动所有者, 只是借用.
    * 引用的指针指向原变量的指针
* 引用是`借用`, 原变量不是可更改的就一定不能修改.
    * 如果想修改
        * 原变量必须声明为可变 `let mut s = String::from("-");`
        * 实参也必须是可变引用 `&mut s`
        * 引用类型也必须声明为可变引用类型 `&mut String`
* rust为了避免竟态修改数据, 一个变量在使用了可变引用的情况下, 同一作用域内
    * 无法再获取可变引用
    * 被使用的可变引用的声明的下方, 无法再获取不可变引用
    * 被使用的可变引用上方获取的不可变引用, 不使用的话不会报错
    * 注意只定义不使用的话没问题
* rust自动避免悬垂指针(内存释放掉了, 但是指针还在)的情况
    * 比如作用域内定义变量, 并返回引用. 作用域结束后变量释放, 引用就空了, rust在编译阶段提示.

### 切片(slice)
* 引用的一种(同样没有所有权), 获取集合中的一段连续的内容, 而不是完整内容
* as_bytes()获取字节数组 iter()获取迭代器 enumerate()返回索引和项目
* 获取切片时, 也是用引用符号, 同时提供范围, 例如`let s = &str1[0..2];`
    * 切片时, 省略左侧表示从0开始, 省略右侧表示最大长度
    * 字符串切片的类型是str
* 字面字符串就是一个不可变的切片
* 数组也可以做切片, 数字数字切片类型为`&[i32]`

## 05 结构体(struct)

### 定义和实例化
* 对比元组
    * 都是一组数据, 结构固定
    * 结构体的每个字段都有意义, 不像元组一样只靠索引来区分
* 自定义的数据结构, 相当于面向对象的Class
    * `struct`关键字定义, 约等于class关键字
    * 大括号里是字段(`field`) `key: type` 结构
* 创建实例时, 直接使用 名字 , 然后大括号里按照 `key: value` 的形式赋值, 没有java那种new关键字
* 结构体赋值的变量如果是可变的, 可以修改字段
    * 比如整体可变, 不能定义某个字段为可变
    * 通过`名字.字段名`来取值/赋值
* 赋值的时候, 有js那种简单写法, 变量和属性同名时候, 直接`字段名,`即可
* 从一个结构体取出字段, 赋值给其他变量(包括其他结构体的字段)后, 该字段的变量的所有权就移交出去了, 无法继续获取
    * 即使这个结构体是不可变的, 仍然会有这样的情况, 不过编辑器就能识别
    * 例子中字符串进行了移交, 如果是实现了`Copy`这个`trait`就会复制一个实例去移交, 原实例依旧有效
* 使用 `..` 语法, 可以使用一个结构体来填充剩余属性, 该语法必须放在最后
    * 使用`..`去填充字段, 也会导致所有权从原始结构体释放
    * 只能对结构体使用, 不能对结构体的切片使用
    * 和js对比: rust只能放在末尾, 只会覆盖剩余属性, 2个点而不是3个点
* 元组结构体
    * 同样使用`struct`关键字, 但是使用小括号而非大括号来定义, 且字段匿名
    * 需要使用分号来结尾
    * 解构时, 需要使用一个元组结构体来接受 `let Tuple (t2) = t1;`
* 可以创建一个不含字段的结构体, 用来实现`trait`
* 上面的例子使用了拥有所有权的字符串, 其实也可以使用引用来作为字段的类型, 但是需要配合生命周期使用, 后期会学到
* 使用结构体的引用来计算表达式, 可以避免所有权转移

### 打印结构体
* 要想结构体能够被`print`, 可以实现Debug这个trait`#[derive(Debug)]`, 然后使用`:?`占位, 或者美化后的`:#?`占位输出
* 通过`dbg!`打印, 会获得并返回参数的所有权
    * 如果传入引用, 不会影响所有权
    * 同样需要实现Debug这个trait

### 方法
* 定义在结构体上叫做方法, 外面的叫函数, 都是fn定义
    * 数据和行为分离, 结构体只是数据, 行为通过impl附加
* 方法的第一个参数都是self, 指向调用的结构体实例
* 通过impl关键字在结构体上定义方法, 可以使用引用, 也可以直接获取所有权, 也可以是可变引用
    * 引用可以用`&self`缩写, 所有权可以直接写`self`, 可变引用使用`&mut self`缩写
* 方法和字段可以同名
* 使用时通过点来调用
* 关联函数: 定义在结构体上, 但是第一个参数不是self, 使用`::`调用, 使用`Self`简写来作为当前结构体的类型
* 一个结构体可以定义多个impl块, 一个impl块也可以写多个方法

## 06 枚举(enums)

### 定义
* `enum`关键字, 然后是枚举名, 大括号中是枚举值(变体 variants)
* 使用时, 和关联函数类似, 使用`::`获取枚举值, 枚举值的类型就是枚举类型
* 变体可以直接附加数据, 定义时通过小括号声明类型
    * 不同的变体, 可以附加不同的数据类型
* 枚举也可以使用impl块来定义方法
* rust中没有空(null), 通过Option枚举来表示, 要么是None, 要么是Some(T)
    * 因为使用广泛, 已经prelude了(预引用), 甚至不需要枚举的前缀可以直接使用None和Some
    * 用于标记可以为空的情况, 来强制进行空处理

### match
* 通过match可以匹配枚举
* 对于附加了值的枚举, 匹配项目需要声明型参来接受数据
* 使用`match`关键字来处理变量, 大括号里面是匹配逻辑, 每个分歧格式为 `类型 => 表达式`
* 所有的分歧必须全部覆盖到, 不然无法编译
    * 可以使用`other`放在最后作为默认值, 通过other可以获取到这个值的实际内容
    * 还可以使用占位符`_`来作为默认处理, 这样也会匹配所有分歧, 但是拿不到实际值
    * 对于不需要处理的分歧, 可以用unit空元组占位

### if let
* `if let`语法用于简化match的只需要处理一个分歧的情况, 属于语法糖
    * 左侧相当于match的要处理的那个分歧, 右侧是变量和表达式
* 还可以包含`else`, else的分歧就是match的`_`分歧
* `let else`用于在匹配时把匹配的参数绑定到外层作用域, 不匹配指向else分支并return掉整个函数
    * 格式为 `let 模式 = 变量 else {}`

## 07 模块化

### crate 和 package
* 编译最小单位是crate
    * 使用rustc去编译单个文件时, 这个文件就是crate
    * crate可以包含其他文件的模块, 编译时会一起编译
* crate的2种形式
    * 二进制: 包含main函数, 编译为可执行程序
    * 库: 没有main函数, 用于提供其他项目使用的功能模块
* 包是包含了一个或者多个crate的文件夹, 包含一个Cargo.toml
* 一个包至少包含一个crate, 最多包含一个库crate, 可以包含多个二进制crate

### 模块的作用域
* 根节点
    * 默认情况下, 包会把`src/main.rs`作为二进制crate的根, 把`src/lib.rs`作为库crate的根
* 模块
    * 使用`mod`关键字在根文件来声明模块, 例如`mod a`
    * 模块的代码存放位置
        * 內联, 直接用大括号写代码
        * `src/a.rs`
        * `src/a/mod.rs`
* 子模块
    * 使用`mod`关键字在非根文件来声明模块, 例如在`src/a.rs`这个模块中声明`mod b`
    * 子模块的代码存放位置
        * 內联, 直接用大括号写代码
        * `src/a/b.rs`
        * `src/a/b/mod.rs`
* 使用路径
    * 以`src/a/b.rs`模块中的`C`类型为例, 可以通过`<文件夹名>::a::b::C`访问
* 默认父模块无法访问子模块, 需要通过`pub mod`来声明
* `use`用来通过完整路径引入模块, 再使用时就可以不用写完整路径了

### 引用模块
* 使用文件夹(路径)结构来引用, 用双冒号`::`分割文件夹
* 除了从顶层开始绝对路径, 还可以使用相对路径向下引用
* 还可以通过`super`关键字向上调用, 相当于文件夹的`..`
* pub模块的内容也必须分别声明pub才能暴露出去
    * 可以使用同级别的非pub模块
    * pub的结构体, 字段也需要使用pub才能暴露
        * 如果有非pub的字段, 则需要提供关联函数来实例化
    * pub的枚举, 所有分歧自动变为pub

### use
* 使用use可以把模块引入, 模块内的内容可以直接使用不用写全名
* 开发规约是不直接use到方法级别, 只到模块级别, 比如通过模块::方法调用, 来表明是引入的
* 不能引入同名的内容, 比如同名方法
    * 可以通过as, 对重名的内容重命名
* use导入后, 当前模块可用, 上层仍然不可用
    * 可以通过pub use xx来暴露出去
* 对于标准库(std)需要手动use
* 相同模块下的不同内容, 可以用大括号一次性引入, 例如 `use std::{cmp::Ordering, io};`
    * 还需要引入最上级模块时, 使用self, 例如`use std::io::{self, Write};`
* 可以使用`*`作为通配符, 引入模块下所有内容

### 拆分
* 內联声明存在时, 不会在加载文件夹结构中的声明
* 模块名/mod.rs属于是老风格, 直接用模块名.rs是新风格

## 08 集合
* 标准库提供, 存储多个值
* 存储在堆上, 所以可变长 (回顾一下, 元组和数组是不可变长的栈数据)

### 向量(Vec)
* 内存中相邻排布
* 存储的类型必须相同
* 声明范型的类型`let v: Vec<i32>`, 通过`Vec::new()`创建
* 也可以直接通过宏来初始化并推断类型 `let v = vec![1, 2, 3]`
* 增 `push`
* 读 `[index]` 或者 `get`
    * 索引能触发越界
    * get会返回option, 越界拿到none
    * 可以配合&拿到引用
* 获取元素引用后, 再去push也会报错, 是因为如果内存不足放下连续的数据, 会整体移动到另一块内存
* 可以通过for in来遍历
* 获取可变引用后可以修改内容
    * 通过 解引用运算符`*` 来修改值 `* & mut v1[1] = 12;`
    * 循环中不能修改长度(插入, 删除)
* 如果想要vec存储不同类型, 可以通过枚举包装
    * 枚举的变体定义为不同类型, 但是在vec看来, 都是枚举类型
* `pop` 移除并返回最后一个元素
* vec的元素的作用域不会超过vec

### 字符串
* 核心语言字符串类型: str
    * 切片为常数字符串
    * utf8编码
* 标准库字符串: String
    * 可变长
    * utf8编码
* 和vec类似, 都是`::new()`创建
    * 本质上vec的封装
* 还可以`String::from("")`来根据str创建, 或者通过`str.to_string()`获得
* 通过`push_str`追加str到`String`
* 通过`push_str`追加char到`String`
* 可以通过`+`拼接 `String` 和 (`&String`或者`&str`)
    * `&String` 可以被强制转换为 `&str`
    * 左侧的字符串会获得所有权, 导致后续不能使用
* 要拼接的内容很长时, 用`format!`宏比加号更方便
    * 不会获得所有权
* utf8存储字符串, 可能占用多个字节, 按照索引取出来不是完整内容, 没有意义
* 使用切片取得时, 仍然可能发生异常
* 可以使用遍历取完整字符
    * 使用.chars()取得字符, 是完整的文字
    * 使用.bytes()取得字节, 是不完整utf8编码
* 通过`contains`可以判断是否包含某些内容
* 通过`replace`可以生成一个替换后的字符串
* 字面的字符串可以换行写
    * 多行字符串的`\`能过避免换行

### 哈希map
* 键值对, 需要手动从std引入
* 键和值必须都是相同类型
* 通过`::new()`创建
* 通过`insert`添加
    * 如果原值存在, insert会覆盖
* 公共`get`获取`option`值
    * 参数需要是引用
* `copied`可以复制一个值, 而不是拿到引用
* `unwrap_or`可以处理none为默认0
* 可以for遍历, 例如`for (key, value) in &map`
    * 顺序不可预测
* 把数据放入map会失去所有权, 转移为map所有
    * 如果放入的是引用, 需要保证map的生命周期内, 引用的源头可用
* 通过`entry`判断值是否存在, 不存在执行`or_insert`, 存在不更新
    * entry获得的引用, 使用*解引来修改值
* 默认使用`SipHash`的hash算法, 安全但是性能较差, 可以替换来加速

## 09 错误处理

### 不可恢复错误
* 使用`panic!`宏来抛出错误, 参数的字符串来提示原因
* 默认情况, 发生panic会展开(回溯清理数据), 不需要展开时可以设置 `panic = 'abort'`
* 想要打印调用栈, 需要设置环境变量`RUST_BACKTRACE`不为0

### 可恢复错误
* Result枚举类型, 包含Ok和Err这2个变体
* 对枚举进行match, 并对Err类型再次match进行细节处理
    * 获取Err.kind()的错误类型
* 可以用闭包简化match
* unwrap会获取Ok的值, Err会panic
* expect能够指定panic的值, 正常分歧返回Ok的值, 比直接unwrap更友好
* 在Err分歧, 返回一个Err()枚举, 可以把错误抛出去由上层处理
    * rust提供了`?`运算符来简化
        * Ok继续执行并获取值
        * Err直接抛出Err分歧
        * 例如`let mut username_file = File::open("hello.txt")?;`
    * 还可以通过`?.`进行链式操作
    * `?`除了Result, 还能配合Option使用, Some会继续, None直接返回
* main函数除了可以返回空元组, 还可以返回`Result<(), Box<dyn Error>>`

### 什么时候用panic
* 测试和demo的时候, 使用unwrap和except
* 人工能确保一定不会进入的异常分歧
* 无法修复或者处理的情况
* 产生风险的情况

## 10 范型和生命周期

### 范型
* 适配不同的类型
* 规范也是用T来声明
    * 函数名后面加`<T>`
    * 后续类型中用T作为类型
    * 结构体的`<T>`加在结构体名后面
    * 枚举的`<T>`加在枚举名后面
    * 方法的`<T>`加在impl后面, 这样结构体就能使用`<T>`
        * 如果方法的范型和结构体无关, 则只需要在方法名后加`<T>`
* 多个范型类型用逗号分隔
* 可以在impl时, 指定结构体的范型的具体类型, 这样只有特定类型才能使用该方法
* 范型在编译后, 会根据每个使用的类型生成具体的代码, 这样就没有额外的运行时消耗

### 共通行为(trait 特质)
* 类似于接口的概念, 定义抽象的共通行为
* 使用关键字`trait`定义, 大括号内定义抽象的方法(没有方法体), 分号结尾
* 通过`impl TRAIN_NAME for STRUCT_NAME`来实现trait中声明的方法
* 孤儿原则: trait或者结构体, 必须有一个属于当前crate才行
    * 也就是当前crate的结构体可以实现其他包的trait, 其他包的结构体可以实现当前crate的trait
    * 但是其他包的结构体不能实现其他包的trait
* trait不只可以包含抽象方法, 还可以包含默认方法体, 不去覆盖的话, 使用默认方法体
* `impl TRAIN_NAME`可以作为类型
    * 实际上是语法糖, 原本为`fn xx<T: TRAIN_NAME>(param: T)`, 叫做`trait bound`, 可以现在多个参数为同一类型
    * 多个`trait`用`+`号连接, 表示需要实现多个特质
    * where语言可以在`trait bound`时只声明范型关键字, 具体类型放在where语句中, 例如`fn some_function<T, U>(t: &T, u: &U) -> i32 where T: Display + Clone, U: Clone + Debug, {}`
    * 作为返回类型时, 也可以用`impl TRAIN_NAME`作为类型, 只适用于单返回类型的情况
* 在范型中限制实现的trait, 只针对这些类型实现方法
    * 可以通过范型来为所有该类型实现一个trait, 叫做`blanket implementations`, 例如`impl<T: Display> ToString for T {...}`

### 生命周期
* 生命周期也是范型, 为了避免悬垂引用(dangling references) (内存释放, 引用未销毁)
* 每一个引用都有生命周期, 也就是引用有效的作用域, rust的借用检查器来确保引用都是有效的
* 当多个分歧影响到生命周期时, 需要明确告诉借用检查器生命周期
* 生命周期注解只是描述生命周期的关联关系, 不会产生实际影响, 使用单引号`'`开头, 例如`'a`, `&'a str`, 作为范型传入
    * 函数的生命周期注解只会出现在声明上(用于rust检查), 而不会出现在函数的代码块中
* 通过生命周期范型在函数上声明, 并且2个参数都使用了这个生命周期范型时, 取的是2个实参声明周期的交集(也就是小的那个作用域)
* 结构体上也能添加生命周期范型, 意味着结构体和字段的生命周期一致
    * 实现方法时, impl后需要提供生命周期注解, 或者用`<'_>`
* 省略生命周期注解的3条规则, 3条规则结束后没有得到输出的周期就不能编译
    * 为每个参数创建一个周期注解
    * 如果只有一个参数, 输出为参数的周期
    * 如果第一个参数为self, 输出为self的周期
* 静态生命周期`'static`, 在程序运行期间一直有效
    * 注意这个值虽然一直有效, 但是仍然只能在作用域内使用
* 生命周期范型和普通范型一起放在尖括号内

## 11 测试

### 编写测试代码
* 方法上添加`#[test]`就能在编辑器单独运行测试(本质是`cargo test`额外传递了参数)
    * 添加后该方法无法在`cargo run`时调用
* 通过宏`assert_eq!`进行断言, 使用`PartialEq`的`trait`来比较, 标准类型只会比较字面值而不会比较内存地址
    * 不相等用`assert_ne!`宏
    * 由于失败时要打印值, 还需要派生`Debug`的`trait`
* 发生`panic`会判定为失败
* `assert!`宏接收布尔参数, `true`会通过测试, `false`会`panic`
    * 可以额外接收一个格式化字符串和字符串的参数, 来在失败时进行提示
* 在方法上声明`#[should_panic]`可以期望`panic`, 不发生`panic`会失败
    * 可以添加`expected`参数, 来期望指定的`panic`消息(的一部分, 局部匹配就通过)
* 测试函数可以返回`Err`类型, 所以可以用?表达式, 失败时抛出`Err`的内容

### 运行测试代码
* `cargo test`执行所有测试, 分为普通参数(给`cargo test`的参数)和`--`参数(给编译后二进制文件的参数, 先使用一个`--`分隔, 后面写这种参数)
* 测试默认并行, 通过`--test-threads`设置并发线程数
* 默认通过的测试不显示输出, 通过`--show-output`开启
* 默认运行全部测试, 通过拼接函数名来运行部分测试
    * 无法指定多个函数名
    * 支持模糊匹配, 包含指定的函数名就能运行
* 函数上添加`#[ignore]`可以在运行时忽略, 通过`--ignored`参数单独运行忽略掉的测试, 或者`--include-ignored`参数运行包含忽略的所有测试

### 测试的结构
* 单元测试
    * 隔离环境单独测试一块代码
    * 可以测试私有接口
    * 单元测试和目标文件放在同一个文件中
    * 每个文件都应该有单元测试
    * 测试模块`tests`, 使用`#[cfg(test)]`标注模块(只在测试时使用, 不会被build)
    * 模块中通过`use super::*;`引入文件中其他方法, 包括私有方法来测试

* 集成测试
    * 作为外部模块来测试
    * 固定放在`tests`目录下
    * 方法上仍然需要添加`#[test]`
    * 单元测试失败后不会执行集成测试
    * 默认执行所有`tests`目录下的文件
        * 通过`cargo test --test FILE_NAME`单独运行一个集成测试, 精确匹配文件名
        * 测试中的共通部分, 固定放在`tests/common/mod.rs`文件中, 使用时需要`mod common;`, 然后可以`common::xx()`调用
    * 二进制crate不能进行集成测试, 所以最好`main`只保留入口, 来调用`lib`, 提高可测试性

## 12 一个grep cli

### 接收cli输入
* 标准库中`std::env::args`可以接收二进制的参数, 可以迭代或者通过`collect`生成`Vec`
    * 获得的第一个项目是文件名, 后面是其他空格分隔的命令行参数
    * 引用外部包参考之前的规范, 只`use`到`env`这一层, 使用时`env::args`来使用, 避免和内部方法混淆

### 读取文件
* 标准库中`std::fs`可以操作文件, 通过`read_to_string`获取文件内容

### 重构
* 从main方法提出函数
* 使用结构体比元组可读性更高
* 初始化的解析逻辑放在结构体的构造方法中
* 详细的描述错误, 便于调试调查
* 使用Err而非直接panic
* 错误的时候使用code1进行退出
* 把逻辑从main挪到lib

### TDD
* 测试驱动开发
    * 编写失败的测试, 确保失败愿意和期望一致
    * 开发/修改代码来让测试通过
    * 重构/修改代码后测试仍然通过
    * 重复上述步骤

### ENV
* 标准库中`std::env::vars`可以获取环境变量
* 参数是变量名, 返回Result

### Error output
* 通过`eprintln!`可以写入标准错误中

## 13 函数式语法特性

### 闭包
* 把匿名函数作为变量
* `unwrap_or_else`接收一个无参闭包, 返回和`Option`的范型相同的类型
* 闭包用2个竖线`||`分隔参数和函数体, 参数在竖线中间
* 闭包的类型大多可以推断, 所以可以省略
    * 一个未定义类型的闭包, 第一次调用时会推断并锁定类型, 后续需要相同类型才能使用
* 如果闭包只有一个表达式, 大括号也可以省略
* 定义成变量后, 也可以通过`变量名()`调用
* 允许捕获定义时作用域里面的变量
    * 不可变借用 / 可变借用: 根据闭包内是否修改来推断. 闭包结束则借用结束
    * 获取所有权: 通过`move`关键字, 放在第一根竖线之前
* 闭包的类型`trait`
    * `FnOnce` 只能调用一次的闭包. 所有闭包至少实现这个`trait`
    * `FnMut` 不会将捕获的值移出, 可能会修改捕获的值. 可以多次调用
        * 移出, 就是交出所有权, 所以重复执行时, 没法再交出所有权了
    * `Fn` 不会移出, 也不会修改捕获的值. 可以多次调用

### 迭代器
* 迭代器是惰性的, 只是创建(执行`.iter()`方法), 没有消费的话不执行任何操作
* for本质循环就是创建了迭代器来遍历
* 迭代器都实现了`Iterator`的`trait`, 包含`next`方法, 返回包含元素的`Some`, 迭代结束返回`None`
* 迭代器调用`next`方法会消费(影响迭代器内部状态), 所以迭代器需要是`mut`的
* `iter`生成不可变引用的迭代器
    * `into_iter`生成所有权迭代器
    * `iter_mut`获取可变引用迭代器
* sum这一类方法数据是消费适配器, 会遍历迭代器; 而map这一类方法是迭代器适配器, 会产生一个新的迭代器

### 例子
* 把上一章的例子从向量参数改为迭代器参数

### 性能
* 迭代器性能和for循环是一致的
* 零开销: 不使用的功能无需为其付出代价; 而已经使用的功能，也不可能通过手写代码做得更好

## 14 Cargo

### profile
* 默认包含了dev和release的profile
    * `[profile.dev]` opt-level为0, 表示不进行优化, 编译更快, 牺牲了运行速度
    * `[profile.release]` opt-level为3, 表示进行最大化优化, 编译更慢, 运行速度更快

### cargo io
* 公有的源, 相当于pypi和npmjs
* 使用`///`来写方法的文档注释, 支持md格式
    * 写在方法名上面
    * 使用`cargo doc`来生成文档
    * rust类型的代码块中的内容会在测试时执行
* 使用`//!`来写模块级别的文档注释
    * 写在文件顶部
* 模块的层级结构对于创建者来说有意义, 但是使用者可能很困惑(得在文档中一层层点下去)
    * 可以使用`pub use self::xx::xx`来把子层级的内容暴露到上层, 会在文档生成`Re-exports`块, 可以直接点进去
* 发布共有包需要使用github账户登录cargoio, 然后拿到api token, 使用`cargo login`命令登录
    * 配置`Cargo.toml`, 确保名字未被注册, 并填写`license`
    * 发布后, crate就不能被删除和修改了, 只能发布新版本
    * 可以撤回某个版本, 但是已经使用了这个版本依赖的项目(cargo.lock包含这个版本)仍然能继续使用, 新项目(cargo.lock不包含这个版本)无法引用
        * 撤回操作可以撤销
        * 撤回只是阻碍新项目使用, 不会删除crate

### cargo workspace
* 大型项目可能需要单独拆分lib
* 入口(main, 二进制)所在的`Cargo.toml`, 添加`[workspace]`来定义工作区, 类似于`monorepo`的概念
* 入口使用`cargo new`来创建子lib
    * 子lib的构建产物也存在在根目录target之下, cargo.lock也在只有根目录才有, 确保不同模块使用相同版本的依赖
        * 其他模块引入了外部包后, 该模块想要使用, 也必须明确声明依赖才能使用
    * 为了lib和入口能够使用子lib, 需要在`Cargo.toml`中添加依赖, 使用相对路径来引入对应的crate
        * 例如: `child2 = { path = "../child2" }`, 这样child1就能使用child2了
    * 根目录也能执行子模块的测试, 例如`cargo test -p child2`

### cargo install
* 可以安装已经在cargo io注册的二进制crate, 例如`cargo install ripgrep`
    * 通过`cargo uninstall`卸载, 例如`cargo uninstall ripgrep`
* 还可以通过`--path`参数安装本地的crate
* 默认安装路径在`$HOME/.cargo/bin`

### cargo自定义命令
* 构建二进制的crate, 名称为`cargo-xxx`, 并添加该二进制文件在path中
* `cargo --list`就可以看到名为`xxx`的自定义命令, 执行`cargo xxx`会执行该二进制文件

## 15 智能指针
* 指针就是包含内存地址的变量, 这个内存地址指向了其他数据
* rust指针分为借用和智能指针这2种, Vec和String就是智能指针
* 智能指针实现了`Deref`和`Drop`这2个trait

### Box
* 把值放在堆上而非栈上(栈上保留一个指向目标堆的指针)
* 为什么要这么做
    * 栈的大小是固定的, 而堆可以动态分配内存, 用来存放不固定大小的数据. 例如创建递归类型
        * 创建递归类型时, 如果正常定义类型, 会导致无法在编译时计算得知数据大小(普通的枚举只需要使用最长的变体的长度作为枚举长度)
        * 递归类型的大小不固定, 所以需要放在堆上, 而Box的大小固定(指针大小固定, 和数据大小无关), 可以在子项目使用Box来指定堆上的下一个项目
        * 递归处理下一项时, 通过解引用运算符`*`来获取Box的指针指向的堆数据来继续处理
    * 栈里面数据复制会创建副本, 而堆是移动, 数据量大时, 会产生很大的数据冗余
    * 只关注是否实现了特定trait的时候
* 在离开作用域后, Box会把堆和栈上的数据都释放掉
* 通过`Box::new()`来创建实例

### Deref trait
* 实现了`Deref`的trait, 可以通过`*`运算符来访问引用的指向
    * 解引用和引用是一对相反的运算符
* 需要实现`deref`方法, 告诉解引用时候要使用哪个引用
    * type为关联类型
    * `&self.0`为获取元组结构体的第一个字段的引用
* 先返回引用, 再通过解引用主要是为了解决所有权问题, 这样获取的指向不会获取所有权
* rust在处理引用时会进行强制类型转换, 例如方法参数定义为`&str`时, 可以传入`MyBox<String>`的引用
    * 第一次转换, 通过deref方法, 把`Box`转为`String`
    * 第二次转换, 通过deref方法, 把`String`转为`str`
    * 编译时处理, 不影响运行速度
* rust还提供了`DerefMut`来返回一个可变借用

### Drop trait
* 用于在超出作用域后释放资源
* 在释放时, 会按照创建的顺序的相反顺序来释放
* 不允许手动调用结构体的`drop`方法, rust会自动调用完成清理
* 需要提前手动清理时, 调用`std::mem::drop`并传入结构体实例

### Rc
* 引用计数, 在所有者(strong_count)为0时自动销毁. 
* 适用于(单线程程序中)共享所有权的情况, 也就是堆上放置一些多个地方读取的数据, 编译时无法确定执行(读取)顺序
* 通过`Rc::new()`来创建实例, 通过`Rc::clone()`增加引用计数(也可以使用`实例.clone()`方法, 但是不利于区分实例的复制和rc的引用计数增加)

### RefCell
* 运行时强制借用规则(也是在单线程使用)
    * Box这种通用的借用, 需要在编译时就保证借用规则, 也就是同时只有一个可变引用或者多个不可变引用, 并且引用始终有效
    * RefCell不会在编译时检查, 而是在运行时确保满足借用规则, 不满足会发生panic
* 内部可变性模式: 在不可变的值内部改变值
* 使用`RefCell`来包裹不可变的值, 通过`borrow_mut`方法获取可变引用, 通过`borrow`方法获取不可变引用
    * 每次调用`borrow_mut`方法, 会记录可变指针数+1, 当可变指针数超过1时, 会发生panic
* 使用场景: 例如有一个属性, 原本是Vec类型, 需要在运行时push, 但是只能拿到不可变引用, 为了不修改声明, 就需要包裹成`RefCell<Vec<T>>`来获取可变引用再push
* 组合Rc和RefCell, 可以实现在多个地方修改数据

### 内存泄露
* 循环引用会导致内存泄露, Rc的所有者永远不会为0所以会导致内存无法释放
    * 例如Rc里面是RefCell的嵌套情况
    * 先创建a, 然后b的RefCell指向a
    * 再修改a的RefCell指向b
    * 此时a和b互相引用, Rc永远不为0
* 使用`Rc::downgrade`获取弱引用, 会导致`weak_count`的值增加
    * 通过`upgrade`方法来获取`Option`类型的数据
    * 例如父子节点的情况, 父节点持有子节点的强引用, 子节点持有父节点的弱引用
        * 不会循环引用
        * 子节点不会影响父节点的销毁

## 16 并发
* 并发: 不同部分独立执行. 并行: 不同部分同时执行

### 多线程
* 通过`thread::spawn`传入闭包, 创建线程
    * 主线程结束后, 所有线程也会被强制结束
    * 创建线程返回handler, 可以调用join方法来等待线程执行结束
* `thread::sleep`来让线程休眠, 此时操作系统会调度执行其他线程
* 通过`move`关键字, 把所有权移动到闭包内

### 消息通信
* 参考了go的思想, 不通过共享内存, 而是通过消息共享数据
* 通过`mpsc::channel`创建通道
    * mpsc(multiple producer, single consumer)多生产者, 单消费者
    * 任意一方丢弃, 则通道关闭
    * 返回一个元组, 包含发送端transmitter和接收端receiver
    * `send`方法发送数据
        * 会移交所有权
    * `recv`方法接收数据, 如果没有数据则阻塞等待
        * 通过`try_recv`非阻塞接收, 需要自己写循环来处理
    * 可以直接遍历接收端, 每次收到数据进入循环
    * 发送端可以克隆, 这样多个发送端都能发送数据

### 共享内存
* 多个线程共同访问同一块内存
* 互斥器(Mutex): 取值前加锁, 用完后释放
* 如果获取锁之后panic了, 就没人能再获取锁了
* lock返回的也是智能指针, 实现了Deref和DerefMut, 超过作用域会自动解除锁
* Arc是Rc的线程安全版本
    * Mutex是RefCell的线程安全版本
        * 注意避免死锁
    * 对于简单运算, 还提供了`AtomicI32`之类来实现原子操作

### trait
* `Send`用来标记可以在线程间传递所有权
* `Sync`用来标记可以在多个线程间共享引用

## 17 异步

### feature
* 和js的promise类型, async块内可以await一个feature值
    * rust的await是放在变量之后的, 和js放在前面不同
    * async声明的函数会自动用Feature包裹返回值
        * 和同步方法返回异步代码块的形式是等价的
    * 只有async内能够await, main不能是async的
        * 异步操作需要异步运行时, main只能初始化运行时, 本身不是运行时
* feature也是惰性的, 在await之前不进行操作
* 添加`trpl`依赖, 来读取并解析html
    * `trpl::run`来启动异步运行时, 传入async代码块
    * `race`来进行竞争, 任意一个先完成的作为结果

### 并发和async
* trpl也有类似于并发的语法, 例如`spawn_task`, `sleep`, 
    * `spawn_task`会返回一个handle, 可以调用await来等待, 达到类似于join效果
    * `join`方法可以传入多个feature, 等待全部完成, 返回一个元组, 包含每个异步的结果
* 但是2者还是存在区别的
    * 并发是多线程, async是单线程
    * 并发的执行时间由操作系统控制, async执行时间由运行时控制(每个任务相同时间)
* 也有channel方法来构筑通道, send发送消息, recv接收消息
    * 接收到的消息需要await, 而不是直接返回值, 所以也不是阻塞的
    * 和线程的迭代器不同, 这里的await会一直循环不会停止, 线程会在子线程都结束后停止
        * 需要把发送端给move到代码块内, 才能丢弃通道, 正常结束程序
        * 使用`while let`进行循环

### 多个feature
* 3个feature可以使用`join3`然后再await
* `trpl::join!`这个宏可以传入任意长度参数, 还会自动await
    * Feature的Output类型可以不同
* `trpl::join_all`可以传入集合, 手动await来等待所有的异步操作
    * Vec类型元素类型必须相同, 而不同的Feature类型不同
    * 可以通过`Box::pin`来把不同类型的Feature包装成相同类型
    * 还可以通过`pin!`宏来简化, 把Feature(也就是异步块)传入
    * 要求Feature的Output类型相同
* `trpl::race`来竞速, 选用先完成的异步任务作为结果
    * 会按照传入产生的顺序来执行, 遇到await开始执行下一个异步操作, '有些不公平'
* `trpl::yield_now().await;`开启一个让步点(相当于js的`await Promise.resolve()`启动一个微任务)

### 流
* 按顺序处理Feature
    * 例如`trpl::stream_from_iter`从迭代器获取流
    * 例如`ReceiverStream::new(rx)`从通道获取流
* 提供了超时处理, 可以设置超时时间, 流中每个异步操作超时会返回错误
* 流可以做合并操作, 要求2个流的类型相同
* 流可以做限流操作, 使用`throttle`方法, 传入时间间隔
    * 限流不会影响原本方法的执行, 只影响轮询时候的间隔(只影响数据进入流, 而不影响数据产生)
* 通过`take`方法来限制流的数量
* 通过`pin!`来固定流, 保证内存可用

### 异步trait
* Poll, 包含了Pending和Ready这2个变体
    * Pending表示异步操作未完成, 需要再次轮询
    * Ready表示异步操作完成, 包含了结果
* 使用await会隐式的pin
* pin是为了保证内存地址不变, 这样异步操作中可以保存引用
    * 避免自引用的时候, 数据移动了但是自引用没变化, 指向了错误的内存地址
    * 数据内没有引用的时候, 可以自由移动而不需要固定内存 (也就是Unpin)

### 选择
* 多线程适用于每一部分都能单独处理的情况
* 异步适用于大量消息的情况
* 组合使用: 例如使用异步通道, 然后线程来处理并发送消息

## 18 面向对象(OOP)
* 